# ğŸ“„ Episodic Memory Verbalization using Hierarchical Representations
## ê³„ì¸µì  ë©”ëª¨ë¦¬ë¡œ ë¡œë´‡ì˜ í‰ìƒ ê²½í—˜ì„ íš¨ìœ¨ì ìœ¼ë¡œ ê´€ë¦¬

---

## ğŸ¯ í•œ ë¬¸ì¥ ìš”ì•½
> **"ë¡œë´‡ì˜ í‰ìƒ ê²½í—˜ì„ íŠ¸ë¦¬ êµ¬ì¡°ë¡œ ê³„ì¸µí™”í•˜ì—¬ í•„ìš”í•œ ê¸°ì–µë§Œ ì„ íƒì ìœ¼ë¡œ ê²€ìƒ‰í•˜ëŠ” ì‹œìŠ¤í…œ"**

---

## ğŸ“‹ ê¸°ë³¸ ì •ë³´
- **ì €ì**: arXiv 2024 íŒ€
- **ë°œí‘œ**: arXiv 2024.09 (Sept 2024)
- **í•µì‹¬ ê¸°ì—¬**: ê³„ì¸µì  ë©”ëª¨ë¦¬ êµ¬ì¡°ë¡œ ì„ íƒì  ê²€ìƒ‰ ì‹¤í˜„

---

## â“ í•´ê²°í•˜ë ¤ëŠ” ë¬¸ì œ

### ë¡œë´‡ ë©”ëª¨ë¦¬ì˜ ë”œë ˆë§ˆ
```python
memory_problems = {
    "ì •ë³´_ê³¼ë¶€í•˜": "ëª¨ë“  ê²½í—˜ ì €ì¥ì‹œ í­ë°œì  ì¦ê°€",
    "ê²€ìƒ‰_ë¹„íš¨ìœ¨": "ê´€ë ¨ ê²½í—˜ ì°¾ê¸° ì–´ë ¤ì›€",
    "ì¤‘ìš”ë„_êµ¬ë¶„": "í•µì‹¬ vs ì‚¬ì†Œí•œ ê²½í—˜ êµ¬ë¶„ ì—†ìŒ",
    "í‰ìƒ_í•™ìŠµ": "ì˜¤ë˜ëœ ê¸°ì–µ ê´€ë¦¬ ì–´ë ¤ì›€"
}
```

### ì¸ê°„ ê¸°ì–µì˜ êµí›ˆ
- ì¸ê°„ì€ **ê³„ì¸µì ìœ¼ë¡œ** ê¸°ì–µ
- **ì¤‘ìš”í•œ ê²ƒë§Œ** ì¥ê¸° ê¸°ì–µ
- **ì—°ê´€ì„±**ìœ¼ë¡œ ê²€ìƒ‰

---

## ğŸ’¡ í•µì‹¬ ì•„ì´ë””ì–´: Hierarchical Episodic Memory

### 1. íŠ¸ë¦¬ êµ¬ì¡° ë©”ëª¨ë¦¬
```python
class HierarchicalMemory:
    def __init__(self):
        self.memory_tree = {
            "level_0": {  # Raw ì„¼ì„œ ë°ì´í„° (1ì´ˆ)
                "type": "raw_perception",
                "retention": "1ë¶„",
                "size": "100MB/ì´ˆ"
            },
            "level_1": {  # ì´ë²¤íŠ¸ (1ë¶„)
                "type": "event_summary",
                "retention": "1ì‹œê°„",
                "size": "1MB/ë¶„",
                "example": "ì»µì„ ì¡ìŒ"
            },
            "level_2": {  # íƒœìŠ¤í¬ (10ë¶„)
                "type": "task_sequence",
                "retention": "1ì¼",
                "size": "100KB/íƒœìŠ¤í¬",
                "example": "ì»¤í”¼ ë§Œë“¤ê¸°"
            },
            "level_3": {  # ì¶”ìƒ ê°œë… (1ì¼)
                "type": "abstract_knowledge",
                "retention": "ì˜êµ¬",
                "size": "10KB/ê°œë…",
                "example": "ëœ¨ê±°ìš´ ë¬¼ ì¡°ì‹¬"
            }
        }
```

### 2. ì„ íƒì  ì••ì¶• ë° ì¶”ìƒí™”
```python
def compress_memory(self, raw_experience):
    """í•˜ìœ„ ë ˆë²¨ì„ ìƒìœ„ ë ˆë²¨ë¡œ ì¶”ìƒí™”"""
    
    # Level 0 â†’ Level 1: ì´ë²¤íŠ¸ ì¶”ì¶œ
    if is_significant(raw_experience):
        event = extract_event(raw_experience)
        self.level_1.append(event)
    
    # Level 1 â†’ Level 2: íƒœìŠ¤í¬ ìš”ì•½
    if task_completed(self.level_1):
        task_summary = summarize_task(self.level_1[-10:])
        self.level_2.append(task_summary)
        
    # Level 2 â†’ Level 3: êµí›ˆ ì¶”ì¶œ
    if failure_detected(self.level_2):
        lesson = extract_lesson(self.level_2)
        self.level_3.append(lesson)  # ì˜êµ¬ ì €ì¥!
    
    # ì˜¤ë˜ëœ í•˜ìœ„ ë ˆë²¨ ì‚­ì œ
    self.prune_old_memories()
```

### 3. LLM ê¸°ë°˜ ë™ì  ê²€ìƒ‰
```python
class MemoryRetrieval:
    def __init__(self):
        self.llm = LanguageModel()
        
    def search_memory(self, query, context):
        """ì¿¼ë¦¬ì— ë”°ë¼ ì ì ˆí•œ ë ˆë²¨ ê²€ìƒ‰"""
        
        # Step 1: ì¿¼ë¦¬ ë¶„ì„
        query_type = self.llm.analyze(query)
        
        # Step 2: ë ˆë²¨ ê²°ì •
        if "êµ¬ì²´ì  í–‰ë™" in query_type:
            search_level = "level_1"  # ìµœê·¼ ì´ë²¤íŠ¸
        elif "ê³¼ê±° ì‹¤íŒ¨" in query_type:
            search_level = "level_3"  # ì¶”ìƒ êµí›ˆ
        else:
            search_level = "level_2"  # íƒœìŠ¤í¬ ë ˆë²¨
        
        # Step 3: ë™ì  íŠ¸ë¦¬ í™•ì¥
        relevant_nodes = []
        current_node = self.memory_tree[search_level]
        
        while not enough_info(relevant_nodes):
            # í•„ìš”ì‹œ í•˜ìœ„ ë ˆë²¨ë¡œ í™•ì¥
            if needs_detail(query, current_node):
                current_node = expand_to_lower_level(current_node)
            relevant_nodes.append(current_node)
        
        return relevant_nodes
```

---

## ğŸ”¬ ì‹¤í—˜ ê²°ê³¼

### ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±
```python
memory_efficiency = {
    "ê¸°ì¡´_ë°©ì‹": {
        "1ì¼_ë°ì´í„°": "8.6GB",
        "ê²€ìƒ‰_ì‹œê°„": "2.3ì´ˆ",
        "ì •í™•ë„": "62%"
    },
    "ê³„ì¸µì _ë©”ëª¨ë¦¬": {
        "1ì¼_ë°ì´í„°": "120MB",  # 98% ê°ì†Œ!
        "ê²€ìƒ‰_ì‹œê°„": "0.15ì´ˆ",  # 15ë°° ë¹ ë¦„!
        "ì •í™•ë„": "84%"  # ë” ì •í™•!
    }
}
```

### ì§ˆì˜ì‘ë‹µ ì„±ëŠ¥
```python
qa_performance = {
    "ë‹¨ìˆœ_ì§ˆë¬¸": {
        "ì˜ˆì‹œ": "ë§ˆì§€ë§‰ìœ¼ë¡œ ì»µì„ ì¡ì€ ë•ŒëŠ”?",
        "ì‘ë‹µ_ì‹œê°„": "0.1ì´ˆ",
        "ì •í™•ë„": "95%"
    },
    "ë³µì¡_ì¶”ë¡ ": {
        "ì˜ˆì‹œ": "ì™œ ì–´ì œ ì»¤í”¼ ë§Œë“¤ê¸°ë¥¼ ì‹¤íŒ¨í–ˆë‚˜?",
        "ì‘ë‹µ_ì‹œê°„": "0.3ì´ˆ",
        "ì •í™•ë„": "88%"
    },
    "êµí›ˆ_ê²€ìƒ‰": {
        "ì˜ˆì‹œ": "ëœ¨ê±°ìš´ ë¬¼ ë‹¤ë£° ë•Œ ì£¼ì˜ì ì€?",
        "ì‘ë‹µ_ì‹œê°„": "0.05ì´ˆ",
        "ì •í™•ë„": "92%"
    }
}
```

---

## ğŸš€ í˜ì‹ ì  ê¸°ì—¬

### 1. **ì ì‘ì  ë§ê° (Adaptive Forgetting)**
```python
forgetting_policy = {
    "ì¤‘ìš”ë„_ë†’ìŒ": "ì˜êµ¬ ë³´ì¡´ (ì‹¤íŒ¨, ì„±ê³µ íŒ¨í„´)",
    "ì¤‘ìš”ë„_ì¤‘ê°„": "1ì¼ ë³´ì¡´ (ì¼ë°˜ íƒœìŠ¤í¬)",
    "ì¤‘ìš”ë„_ë‚®ìŒ": "1ì‹œê°„ ë³´ì¡´ (ë°˜ë³µ ì‘ì—…)",
    "raw_data": "1ë¶„ ë³´ì¡´ (ì„¼ì„œ ë°ì´í„°)"
}
```

### 2. **ê³„ì¸µ ê°„ ì—°ê²°**
- ìƒìœ„ ë ˆë²¨ì´ í•˜ìœ„ ë ˆë²¨ í¬ì¸í„° ìœ ì§€
- í•„ìš”ì‹œë§Œ ìƒì„¸ ì •ë³´ ì ‘ê·¼
- ë©”ëª¨ë¦¬-ì†ë„ ìµœì  ê· í˜•

### 3. **LLM í†µí•© ê²€ìƒ‰**
- ìì—°ì–´ ì¿¼ë¦¬ ì´í•´
- ì ì ˆí•œ ì¶”ìƒí™” ë ˆë²¨ ì„ íƒ
- ë™ì  íŠ¸ë¦¬ íƒìƒ‰

---

## ğŸ’­ ìš°ë¦¬ ì—°êµ¬ì™€ì˜ ì™„ë²½í•œ ì‹œë„ˆì§€

### Episodic Memory + Adaptive RAG
```python
our_combined_system = {
    "ê³„ì¸µì _ì €ì¥": {
        "ì‹¤íŒ¨_ê²½í—˜": "Level 3 (ì˜êµ¬)",
        "ì„±ê³µ_íŒ¨í„´": "Level 2 (1ì¼)",
        "ì¼ë°˜_ì‘ì—…": "Level 1 (1ì‹œê°„)"
    },
    
    "ì„ íƒì _ê²€ìƒ‰": {
        "Confidence < 0.5": "Level 3 ê²€ìƒ‰ (êµí›ˆ)",
        "Confidence < 0.7": "Level 2 ê²€ìƒ‰ (ìœ ì‚¬ íƒœìŠ¤í¬)",
        "Confidence > 0.7": "ê²€ìƒ‰ ìŠ¤í‚µ"
    },
    
    "ë©”ëª¨ë¦¬_ê´€ë¦¬": {
        "ìë™_ì••ì¶•": "í•˜ìœ„â†’ìƒìœ„ ì¶”ìƒí™”",
        "ì„ íƒì _ë§ê°": "ì¤‘ìš”ë„ ê¸°ë°˜",
        "íš¨ìœ¨ì _ì¸ë±ì‹±": "ê³„ì¸µë³„ ë³„ë„ ê´€ë¦¬"
    }
}
```

### ìš°ë¦¬ê°€ ì§ì ‘ í™œìš©í•  ì 
âœ… **ê³„ì¸µì  êµ¬ì¡°ë¡œ íš¨ìœ¨ì  ê´€ë¦¬**
âœ… **ì¤‘ìš”ë„ ê¸°ë°˜ ì„ íƒì  ì €ì¥**
âœ… **LLM í†µí•© ë™ì  ê²€ìƒ‰**

### ìš°ë¦¬ê°€ ì¶”ê°€í•  ì 
âœ… **Confidence ê¸°ë°˜ íŠ¸ë¦¬ê±°**
âœ… **ì‹¤íŒ¨ ìš°ì„  ì €ì¥ ì •ì±…**
âœ… **ì‹¤ì‹œê°„ ì œì•½ í•˜ ê²€ìƒ‰**

---

## ğŸ“ êµìˆ˜ë‹˜ê»˜ í•  ì§ˆë¬¸

1. "ê³„ì¸µì  ë©”ëª¨ë¦¬ì˜ ë ˆë²¨ì„ Confidenceì™€ ì—°ë™í•˜ë©´ ë” íš¨ìœ¨ì ì¸ ê²€ìƒ‰ì´ ê°€ëŠ¥í• ê¹Œìš”?"

2. "ì‹¤íŒ¨ ê²½í—˜ì„ ìë™ìœ¼ë¡œ Level 3ë¡œ ìŠ¹ê²©ì‹œí‚¤ëŠ” ë©”ì»¤ë‹ˆì¦˜ì€ ì–´ë–¨ê¹Œìš”?"

3. "íŠ¸ë¦¬ íƒìƒ‰ ê¹Šì´ë¥¼ ì‹¤ì‹œê°„ ì œì•½ì— ë§ì¶° ë™ì ìœ¼ë¡œ ì¡°ì ˆí•˜ëŠ” ë°©ë²•ì€?"

---

## ğŸ“ í•µì‹¬ ì¸ì‚¬ì´íŠ¸

> **"ëª¨ë“  ê²ƒì„ ê¸°ì–µí•  í•„ìš”ëŠ” ì—†ë‹¤."**
> **ì¤‘ìš”í•œ ê²ƒë§Œ ì˜¤ë˜ ê¸°ì–µí•˜ê³ ,**
> **í•„ìš”í•  ë•Œë§Œ ê¹Šì´ ê²€ìƒ‰í•œë‹¤.**
> **ì´ê²ƒì´ ì§„ì •í•œ Selective Memoryë‹¤.**

---

## ğŸ”— ì‹¤ì œ êµ¬í˜„ ì˜ˆì‹œ

### ì»¤í”¼ ë§Œë“¤ê¸° ì‹¤íŒ¨ ì‹œë‚˜ë¦¬ì˜¤
```python
# ì‹¤íŒ¨ ë°œìƒ
failure_event = {
    "time": "2024-09-01 10:30",
    "task": "ì»¤í”¼ ë§Œë“¤ê¸°",
    "error": "ëœ¨ê±°ìš´ ë¬¼ ìŸìŒ",
    "cause": "ì»µ ê°ë„ ì˜ëª»ë¨"
}

# ê³„ì¸µì  ì €ì¥
memory.level_0.append(raw_sensor_data)  # 1ë¶„ í›„ ì‚­ì œ
memory.level_1.append("ë¬¼ ìŸìŒ")        # 1ì‹œê°„ ë³´ì¡´
memory.level_2.append("ì»¤í”¼ ì‹¤íŒ¨")       # 1ì¼ ë³´ì¡´
memory.level_3.append("ê°ë„ ì£¼ì˜")       # ì˜êµ¬ ë³´ì¡´!

# ë‹¤ìŒë²ˆ ì»¤í”¼ ë§Œë“¤ ë•Œ
if confidence < 0.7:
    lesson = memory.search("ì»¤í”¼ + ëœ¨ê±°ìš´ë¬¼")
    # â†’ Level 3ì—ì„œ "ê°ë„ ì£¼ì˜" ì¦‰ì‹œ ê²€ìƒ‰
    adjust_gripper_angle(lesson)
```

---

*ì´ ë…¼ë¬¸ì€ ì„ íƒì  ë©”ëª¨ë¦¬ ê´€ë¦¬ì˜ ì´ìƒì  ëª¨ë¸ì„ ì œì‹œí•˜ë©°, ìš°ë¦¬ì˜ Adaptive RAGì™€ ê²°í•©ì‹œ ì™„ë²½í•œ ë©”ëª¨ë¦¬ ì‹œìŠ¤í…œ êµ¬ì¶• ê°€ëŠ¥*